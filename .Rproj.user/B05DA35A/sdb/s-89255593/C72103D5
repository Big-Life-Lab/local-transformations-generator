{
    "collab_server" : "",
    "contents" : "# Hello, world!\n#\n# This is an example function named 'hello'\n# which prints 'Hello, world!'.\n#\n# You can learn more about package authoring with RStudio at:\n#\n#   http://r-pkgs.had.co.nz/\n#\n# Some useful keyboard shortcuts for package authoring:\n#\n#   Build and Reload Package:  'Cmd + Shift + B'\n#   Check Package:             'Cmd + Shift + E'\n#   Test Package:              'Cmd + Shift + T'\n\nlibrary('pryr')\nsource(file.path(getwd(), 'R', './tokens.R'))\n\ngetDerivedFieldNameForTokens <- function(tokens) {\n  symbols <- getSymbolsInTokens(tokens)\n\n  derivedFieldName <- 'unknown'\n\n  for(i in 1:nrow(symbols)) {\n    parentExprForCurrentSymbol <- getExprWithIdInTokens(symbols[i, 'parent'], tokens)\n\n    tokensWithSameParentAsParentExprForCurrentSymbol <- getTokensWithParent(parentExprForCurrentSymbol$parent, tokens)\n\n    if(doesTokensHaveALeftAssign(tokensWithSameParentAsParentExprForCurrentSymbol)) {\n      derivedFieldName <- symbols[i, 'text']\n      break;\n    }\n  }\n\n  if(derivedFieldName == 'unknown') {\n    stop('derivedFieldName is unkown')\n  }\n\n  return(derivedFieldName)\n}\n\ngetPmmlStringForSymbol <- function(symbol) {\n  fieldRefName <- symbol$text\n\n  return(glue::glue('<FieldRef field=\"{fieldRefName}\"/>'))\n}\n\ngetPmmlStringForConstant <- function(constant) {\n  dataType <- 'double'\n  value <- constant$text\n\n  if(typeof(constant) == 'character') {\n    dataType <- 'string'\n  }\n\n  return(glue::glue('<Constant dataType=\"{dataType}\">{value}</Constant>'))\n}\n\ngetPmmlStringForLogicalOperator <- function(logicalToken, nestedPmmlString) {\n  functionType <- 'equal'\n\n  return(glue::glue('<Apply function=\"{functionType}\">{nestedPmmlString}</Apply>'))\n}\n\ngetPmmlStringForMathToken <- function(mathToken, nestedPmmlString) {\n  functionType <- gsub(\"'\", \"\", mathToken$token)\n\n  return(glue::glue('<Apply function=\"{functionType}\">{nestedPmmlString}</Apply>'))\n}\n\ngetPmmlStringForSymbolFunctionCall <- function(symbolFunctionCallToken, nestedPmmlString) {\n  functionType <- symbolFunctionCallToken$text\n\n  return(glue::glue('<Apply function=\"{functionType}\">{nestedPmmlString}</Apply>'))\n}\n\ngetPmmlStringForIfToken <- function(conditionExpr, trueResultExpr, falseResultExpr, tokens) {\n  pmmlStringForTrueExpr <- getPmmlStringForExpr(trueResultExpr, tokens)\n  pmmlStringForFalseExpr <- getPmmlStringForExpr(falseResultExpr, tokens)\n  pmmlStringForCondition <- getPmmlStringForExpr(conditionExpr, tokens)\n\n  return(glue::glue('<Apply function=\"if\">{pmmlStringForCondition}{pmmlStringForTrueExpr}{pmmlStringForFalseExpr}</Apply>'))\n}\n\nisSymbolFunctionCallExpr <- function(exprToken, tokens) {\n  exprTokensWhoseParentIsTheCurrentToken <- getExprTokens(getTokensWithParent(exprToken$id, tokens))\n\n  for(i in 1:nrow(exprTokensWhoseParentIsTheCurrentToken)) {\n    if(getTokensWithParent(exprTokensWhoseParentIsTheCurrentToken[1, 'id'], tokens)[1, 'token'] == SYMBOL_FUNCTION_CALL_TOKEN) {\n      return(TRUE)\n    }\n  }\n\n  return(FALSE);\n}\n\ngetPmmlStringForExpr <- function(expr, tokens) {\n  tokensWhoseParentIsTheCurrentExpr = getTokensWithParent(expr$id, tokens)\n\n  tokensWhoseParentIsTheCurrentExprHasOneRow <- (nrow(tokensWhoseParentIsTheCurrentExpr) != 0)\n\n  if(tokensWhoseParentIsTheCurrentExprHasOneRow & tokensWhoseParentIsTheCurrentExpr[1, ]$token == IF_TOKEN) {\n    conditionExpr <- tokensWhoseParentIsTheCurrentExpr[3, ]\n    trueResultExpr <- tokensWhoseParentIsTheCurrentExpr[5, ]\n    falseResultExpr <- tokensWhoseParentIsTheCurrentExpr[7, ]\n\n    return(getPmmlStringForIfToken(conditionExpr, trueResultExpr, falseResultExpr, tokens))\n  } else {\n    exprTokensWhoseParentIsTheCurrentExpr = getExprTokens(tokensWhoseParentIsTheCurrentExpr)\n    nonExprTokensWhoseParentIsTheCurrentExpr = filterOutExprTokens(tokensWhoseParentIsTheCurrentExpr)\n\n    pmmlStringForExprTokens <- ''\n\n    if(nrow(exprTokensWhoseParentIsTheCurrentExpr) != 0) {\n      if(isSymbolFunctionCallExpr(expr, tokens)) {\n        functionArgsSymbolTokensPmmlString <- ''\n        functionSymbolToken <- getTokensWithParent(exprTokensWhoseParentIsTheCurrentExpr[1, 'id'], tokens)[1, ]\n        exprTokensWhoseParentIsTheCurrentExprAndAreFunctionArgs <- exprTokensWhoseParentIsTheCurrentExpr[-1, ]\n\n        for(i in 1:nrow(exprTokensWhoseParentIsTheCurrentExprAndAreFunctionArgs)) {\n          functionArgsSymbolTokensPmmlString <- paste(functionArgsSymbolTokensPmmlString, getPmmlStringForExpr(exprTokensWhoseParentIsTheCurrentExprAndAreFunctionArgs[1, ], tokens))\n        }\n\n        return(getPmmlStringForSymbolFunctionCall(functionSymbolToken, functionArgsSymbolTokensPmmlString))\n      } else {\n        for(i in 1:nrow(exprTokensWhoseParentIsTheCurrentExpr)) {\n          pmmlStringForExprTokens <- paste(pmmlStringForExprTokens, getPmmlStringForExpr(exprTokensWhoseParentIsTheCurrentExpr[i, ], tokens))\n        }\n      }\n    }\n\n    if(nrow(nonExprTokensWhoseParentIsTheCurrentExpr) == 0) {\n      return(pmmlStringForExprTokens)\n    }\n\n    nonExprToken = nonExprTokensWhoseParentIsTheCurrentExpr[1, ]\n    nonExprTokenToken = nonExprToken$token\n\n    if(nonExprTokenToken == SYMBOL_TOKEN) {\n      return(getPmmlStringForSymbol(nonExprToken))\n    } else if(nonExprTokenToken == NUM_CONST_TOKEN) {\n      return(getPmmlStringForConstant(nonExprToken))\n    } else if(nonExprTokenToken %in% MATH_TOKENS) {\n      return(getPmmlStringForMathToken(nonExprToken, pmmlStringForExprTokens))\n    } else if(nonExprTokenToken %in% LOGICAL_TOKENS) {\n      return(getPmmlStringForLogicalOperator(nonExprToken, pmmlStringForExprTokens))\n    } else {\n      return(pmmlStringForExprTokens)\n    }\n  }\n}\n\ngetDerivedFieldPmmlStringForTokens <- function(tokens) {\n  derivedFieldName <- getDerivedFieldNameForTokens(tokens)\n  symbolsWithDerivedFieldNameForText <- getAllSymbolsWithText(derivedFieldName, tokens)\n\n  tokensToConvertToDerivedFieldPmml <- filterOutLeftAssignTokens(tokens)\n  tokensToConvertToDerivedFieldPmml <- filterOutSymbolsWithText(derivedFieldName, tokensToConvertToDerivedFieldPmml)\n\n  for(i in 1:nrow(symbolsWithDerivedFieldNameForText)) {\n    tokensToConvertToDerivedFieldPmml <- filterOutTokenWithId(symbolsWithDerivedFieldNameForText[i, 'parent'], tokensToConvertToDerivedFieldPmml)\n  }\n\n  transformationPmmlString <- getPmmlStringForExpr(tokensToConvertToDerivedFieldPmml[1, ], tokensToConvertToDerivedFieldPmml)\n  return(glue::glue('<DerivedField name=\"{derivedFieldName}\">{transformationPmmlString}</DerivedField>'))\n}\n\ngetIndexOfNextZeroParent <- function(parseData) {\n  numZeroParents = 0\n\n  for(i in 1:nrow(parseData)) {\n    if(parseData[i,'parent'] == 0) {\n      if(numZeroParents == 1) {\n        return(i)\n      }\n      else {\n        numZeroParents = numZeroParents + 1\n      }\n    }\n  }\n\n  return(nrow(parseData))\n}\n\ngetPmmlStringFromRFile <- function(filePath) {\n  tokens = getParseData(parse(file = filePath))\n  print(tokens)\n  nextZeroParentIndex = getIndexOfNextZeroParent(tokens)\n\n  localTransformationString <- ''\n\n  while(nextZeroParentIndex != 0) {\n    localTransformationString <- paste(localTransformationString, getDerivedFieldPmmlStringForTokens(tokens[0:nextZeroParentIndex+1, ]))\n\n    if(nextZeroParentIndex == nrow(tokens)) {\n      break\n    }\n\n    tokens = tokens[nextZeroParentIndex:nrow(tokens), ]\n\n    nextZeroParentIndex = getIndexOfNextZeroParent(tokens)\n  }\n\n  return(localTransformationString)\n}\n\ncat(getPmmlStringFromRFile(file.path(getwd(), 'R', 'test_math.R')), file=\"out.xml\")\n",
    "created" : 1498761232527.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3249155413",
    "id" : "C72103D5",
    "lastKnownWriteTime" : 1498870483,
    "last_content_update" : 1498870483805,
    "path" : "~/code/R/pmml/R/hello.R",
    "project_path" : "R/hello.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "r_source"
}